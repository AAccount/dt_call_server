removals outside
write timeout outside
NEW unordered_map <string*, pthread*> (persona, pthread*) + (personb, pthread*)

main
	pthread sigmask
	don't add live fd
	**mutex lock when adding to removals
	accept:
		...
		create string* with 1 person's name
		create pthread*
		insert both entries into pthread map
		start pthread, pass in name
		...
		send call start

remove client
	...
	if uname not ""
		**check pthread map has entries for uname first
		get thread from pthread map with established "uname"
		get other person from live list
		get pthread from pthread map
		erase both pthread map entries
		erase both live list entires
		free pthread*

thread
	establish persona from string*
	delete string*
	establish personb from live list
	declare fdsets
	string drop_notify ""
	while
		lookup a media fd, b media fd
		vector<int> (a media fd) + (b media fd)
		select read
		select write
		for i=0; i<2; i++
			other = 1-i
			if(readfd is set i)
				amount = readfd(vector.at(i))
				if amount == 0 //both real call drop and call end produce the same effect
					drop notify = vector.at(other)
					removals add vector.at(i)
					break
				if writefd set(vector.at(other))
					err value write
					if err value has issues
						increment fail counter
				else
					increment fail counter	
				if over failmax
					drop notify = vector.at(i)
					removals add vector(other)
					break
	if drop notify
		write drop









